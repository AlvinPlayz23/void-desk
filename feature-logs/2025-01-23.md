# Feature Log: 2025-01-23

## Summary

This session implemented several major features and documentation for VoiDesk:
1. **File Watching** - Automatic file tree refresh when files change externally
2. **Find & Replace** - Full CodeMirror search integration with keyboard shortcuts
3. **Multi-Language Syntax Highlighting** - Support for JavaScript, TypeScript, Python, and Rust
4. **LSP Implementation Plan** - Comprehensive plan for Language Server Protocol integration
5. **Future Optimizations Guide** - Detailed optimization strategies with code snippets

---

## 1. File Watching Feature

### Overview
Added automatic file system monitoring using the Rust `notify` crate. When files are modified, created, or deleted outside the IDE (e.g., via terminal, another editor, or git operations), the file tree automatically refreshes to reflect those changes.

### Files Created

| File | Purpose |
|------|---------|
| `src-tauri/src/commands/file_watcher.rs` | Rust module for file system watching with debouncing |
| `src/hooks/useFileWatcher.ts` | React hook to manage watcher lifecycle and event handling |

### Files Modified

| File | Changes |
|------|---------|
| `src-tauri/Cargo.toml` | Added `notify = { version = "6", features = ["macos_fsevent"] }` |
| `src-tauri/src/commands/mod.rs` | Added `pub mod file_watcher;` |
| `src-tauri/src/lib.rs` | Registered `start_file_watcher`, `stop_file_watcher`, `is_watching` commands |
| `src/App.tsx` | Added `useFileWatcher()` hook integration |

### Dependencies Added

**Cargo (Rust):**
```toml
notify = { version = "6", features = ["macos_fsevent"] }
```

### Implementation Details

#### Backend Architecture (Rust)

The file watcher uses a global state pattern with `OnceLock` and `Mutex` to persist the watcher across Tauri command invocations:

```rust
static WATCHER: std::sync::OnceLock<Mutex<Option<WatcherState>>> = std::sync::OnceLock::new();

struct WatcherState {
    _watcher: RecommendedWatcher,
    watched_path: String,
}
```

#### Debouncing Strategy

Events are debounced using a tokio channel and `tokio::select!`:

```rust
let (tx, mut rx) = mpsc::channel::<Event>(100);

tokio::spawn(async move {
    let mut pending_events: Vec<Event> = Vec::new();
    let debounce_duration = Duration::from_millis(500);
    
    loop {
        tokio::select! {
            Some(event) = rx.recv() => {
                pending_events.push(event);
            }
            _ = tokio::time::sleep(debounce_duration), if !pending_events.is_empty() => {
                // Process and emit accumulated events
                // ...
                app.emit("file-change", FileChangeEvent { event_type, paths });
            }
        }
    }
});
```

#### Event Flow

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  File System    │────►│  notify crate    │────►│  tokio channel  │
│  (external)     │     │  (watcher)       │     │  (debounce)     │
└─────────────────┘     └──────────────────┘     └────────┬────────┘
                                                          │
                                                          ▼ (500ms)
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  File Tree      │◄────│  useFileWatcher  │◄────│  Tauri emit()   │
│  (refreshed)    │     │  (React hook)    │     │  "file-change"  │
└─────────────────┘     └──────────────────┘     └─────────────────┘
```

#### Frontend Hook

```typescript
export function useFileWatcher() {
    const { rootPath, setFileTree } = useFileStore();
    
    useEffect(() => {
        if (rootPath) {
            // Listen for file-change events
            const unlisten = listen<FileChangeEvent>("file-change", (event) => {
                refreshFileTree(rootPath);
            });
            
            // Start the watcher
            invoke("start_file_watcher", { path: rootPath });
        }
        
        return () => {
            invoke("stop_file_watcher");
        };
    }, [rootPath]);
}
```

### Architecture Decisions

1. **500ms Debounce**: Chosen to balance responsiveness with avoiding excessive refreshes during rapid file operations (e.g., `npm install` creating many files)

2. **Global Watcher State**: Using `OnceLock<Mutex<Option<WatcherState>>>` ensures only one watcher exists at a time and persists across async command calls

3. **Recursive Watching**: `RecursiveMode::Recursive` watches all subdirectories, essential for project-wide monitoring

4. **Event Batching**: Multiple events within the debounce window are batched and deduplicated before emitting

---

## 2. Find & Replace Feature

### Overview
Integrated CodeMirror 6's `@codemirror/search` package to provide full find and replace functionality with keyboard shortcuts.

### Files Modified

| File | Changes |
|------|---------|
| `package.json` | Added `@codemirror/search` dependency |
| `src/components/editor/CodeEditor.tsx` | Added search extensions and keymap |
| `src/index.css` | Added custom styling for search panel |

### Dependencies Added

**npm:**
```bash
npm install @codemirror/search
```

### Implementation Details

#### CodeMirror Extensions

Added to `CodeEditor.tsx`:

```tsx
import {
    search,
    searchKeymap,
    highlightSelectionMatches,
} from "@codemirror/search";

// In EditorState.create() extensions array:
search({ top: true }),  // Show panel at top of editor
highlightSelectionMatches(),

// In keymap:
keymap.of([
    ...closeBracketsKeymap,
    ...defaultKeymap,
    ...historyKeymap,
    ...searchKeymap,  // Added
    indentWithTab,
]),
```

#### Custom CSS Styling

Added VoiDesk-themed styles for the search panel in `src/index.css`:

```css
.cm-search {
    background: var(--color-void-800) !important;
    border-bottom: 1px solid var(--color-border-subtle) !important;
    padding: 8px 12px !important;
    font-family: var(--font-mono) !important;
}

.cm-search input:focus {
    border-color: var(--color-accent-primary) !important;
}

.cm-searchMatch {
    background: rgba(99, 102, 241, 0.3) !important;
}

.cm-searchMatch-selected {
    background: rgba(99, 102, 241, 0.6) !important;
}

.cm-selectionMatch {
    background: rgba(255, 255, 255, 0.1) !important;
}
```

### Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| `Ctrl+F` | Open find panel |
| `Ctrl+H` | Open find & replace panel |
| `F3` | Go to next match |
| `Shift+F3` | Go to previous match |
| `Enter` | Next match (when in find field) |
| `Escape` | Close search panel |
| `Alt+Enter` | Select all matches |

### Features Included

- **Case Sensitivity Toggle**: Click "Aa" button to toggle
- **Regex Toggle**: Click ".*" button to enable regex patterns
- **Match Count**: Shows "X of Y" matches
- **Replace / Replace All**: Available in replace mode (Ctrl+H)
- **Selection Highlighting**: Other occurrences of selected text are highlighted
- **Auto-fill**: Selected text is automatically filled into search field

---

## Testing Instructions

### File Watching

1. Start the app: `npm run tauri dev`
2. Open a project folder
3. In a separate terminal or file explorer:
   - Create a new file in the project
   - Modify an existing file
   - Delete a file
4. **Expected**: File tree updates automatically within ~500ms

### Find & Replace

1. Open any file in the editor
2. Press `Ctrl+F` to open find panel
3. Type a search term
4. **Expected**: Matches are highlighted, count is shown
5. Press `F3` to navigate between matches
6. Press `Ctrl+H` to open replace mode
7. Enter replacement text and click "Replace" or "Replace All"
8. Test regex by clicking ".*" and entering a pattern like `\d+`
9. Press `Escape` to close the panel

---

## Summary of All Changes

### New Files (2)
- `src-tauri/src/commands/file_watcher.rs`
- `src/hooks/useFileWatcher.ts`

### Modified Files (6)
- `src-tauri/Cargo.toml`
- `src-tauri/src/commands/mod.rs`
- `src-tauri/src/lib.rs`
- `src/App.tsx`
- `src/components/editor/CodeEditor.tsx`
- `src/index.css`

### Dependencies Added
- **Rust**: `notify = "6"` (with `macos_fsevent` feature)
- **npm**: `@codemirror/search`

### Tauri Commands Added
- `start_file_watcher(path: String)` - Start watching a directory
- `stop_file_watcher()` - Stop the current watcher
- `is_watching()` - Check if watcher is active

### Events Added
- `file-change` - Emitted when files change (payload: `{ event_type, paths }`)

---

## 3. Multi-Language Syntax Highlighting

### Overview
Added syntax highlighting support for multiple programming languages using CodeMirror 6 language packages. Only essential languages (JavaScript, TypeScript, Python, Rust) are included - HTML, CSS, JSON, and Markdown use syntax-only highlighting without LSP overhead.

### Files Modified

| File | Changes |
|------|---------|
| `src/components/editor/CodeEditor.tsx` | Added language detection and dynamic extension loading |
| `src/hooks/useFileSystem.ts` | Updated language name mapping for status bar |
| `package.json` | Added `@codemirror/lang-*` packages |

### Dependencies Added

**npm:**
```bash
npm install @codemirror/lang-html @codemirror/lang-css @codemirror/lang-json @codemirror/lang-markdown
```

> **Note**: `@codemirror/lang-javascript`, `@codemirror/lang-python`, and `@codemirror/lang-rust` were already installed.

### Implementation Details

#### Language Detection Function

```typescript
function getLanguageExtension(filePath: string): Extension {
    const ext = filePath.split(".").pop()?.toLowerCase() || "";
    switch (ext) {
        case "js":
        case "jsx":
        case "mjs":
        case "cjs":
            return javascript({ jsx: true, typescript: false });
        case "ts":
        case "tsx":
            return javascript({ jsx: true, typescript: true });
        case "py":
        case "pyw":
        case "pyi":
            return python();
        case "rs":
            return rust();
        case "html":
        case "htm":
        case "xhtml":
            return html();
        case "css":
        case "scss":
        case "sass":
        case "less":
            return css();
        case "json":
        case "jsonc":
            return json();
        case "md":
        case "markdown":
        case "mdx":
            return markdown();
        default:
            return [];
    }
}
```

#### Memoized Extension Loading

```typescript
const languageExtension = useMemo(() => {
    if (!currentFile?.path) return [];
    return getLanguageExtension(currentFile.path);
}, [currentFile?.path]);
```

### Supported Languages

| Language | Extensions | LSP Planned |
|----------|------------|-------------|
| JavaScript | `.js`, `.jsx`, `.mjs`, `.cjs` | ✅ Yes (typescript-language-server) |
| TypeScript | `.ts`, `.tsx` | ✅ Yes (typescript-language-server) |
| Python | `.py`, `.pyw`, `.pyi` | ✅ Yes (pyright) |
| Rust | `.rs` | ✅ Yes (rust-analyzer) |
| HTML | `.html`, `.htm`, `.xhtml` | ❌ Syntax only |
| CSS | `.css`, `.scss`, `.sass`, `.less` | ❌ Syntax only |
| JSON | `.json`, `.jsonc` | ❌ Syntax only |
| Markdown | `.md`, `.markdown`, `.mdx` | ❌ Syntax only |

### Architecture Decision

**Why syntax-only for HTML/CSS/JSON/Markdown?**

These languages don't benefit significantly from LSP features:
- **HTML/CSS**: Emmet provides better completions than LSP
- **JSON**: Schema validation is rarely needed in an IDE
- **Markdown**: No type checking or go-to-definition needed

This saves ~80-150 MB of memory by not running additional language servers.

---

## 4. LSP Implementation Plan

### Overview
Created a comprehensive plan for implementing Language Server Protocol support in VoiDesk.

### Files Created

| File | Purpose |
|------|---------|
| `LSP-PLAN.md` | 522-line implementation plan with architecture, phases, and code examples |

### Key Sections in LSP-PLAN.md

1. **Architecture Overview** - Frontend ↔ Rust backend ↔ Language servers
2. **Language Server Selection** - typescript-language-server, pyright, rust-analyzer
3. **4-Phase Implementation Plan** - TypeScript → Python → Rust → Polish
4. **Technical Approach** - JSON-RPC transport, Tauri commands, CodeMirror extensions
5. **State Management** - Document tracking, pending requests
6. **Performance Considerations** - Memory usage, mitigation strategies
7. **Timeline** - 6-8 weeks for full implementation

### Memory Usage Estimates

| Server | Idle RAM | Active RAM |
|--------|----------|------------|
| typescript-language-server | 80-150 MB | 200-400 MB |
| pyright | 100-200 MB | 300-600 MB |
| rust-analyzer | 200-500 MB | 500 MB - 2 GB |

---

## 5. Future Optimizations Guide

### Overview
Created a detailed guide for optimizing syntax highlighting and LSP implementation.

### Files Created

| File | Purpose |
|------|---------|
| `FUTURE-OPTIM.md` | 615-line optimization guide with code snippets |

### Key Optimizations Documented

#### 1. Syntax Highlighting Optimization
- Dynamic imports with caching
- Lazy-load language packages on demand
- Estimated savings: 30-50 KB initial bundle

#### 2. rust-analyzer Optimization
- Activity-based lifecycle management
- 5-minute idle timeout (aggressive)
- Configuration to disable proc macros (-50-100 MB)
- Configuration to disable build scripts (-100-200 MB)

#### 3. Priority-Based Resource Allocation
```rust
pub enum ServerPriority {
    Critical,   // TypeScript - 30 min timeout
    Normal,     // Python - 10 min timeout
    Background, // Rust - 3 min timeout
}
```

#### 4. Tiered LSP Support
```typescript
const lspTiers = {
    full: ["typescript", "javascript"],      // Always available
    onDemand: ["python", "rust"],            // Lazy loaded
    syntaxOnly: ["html", "css", "json", "markdown"],  // No LSP
};
```

#### 5. Additional Optimizations
- Request coalescing (-30% server load)
- Completion caching (5-second TTL)
- Diagnostic throttling (500ms)
- Memory pressure response system

### Implementation Order

1. **Phase 1**: Dynamic imports for syntax highlighting
2. **Phase 2**: Lazy-load rust-analyzer with aggressive timeout
3. **Phase 3**: Tiered LSP support
4. **Phase 4**: Request coalescing and caching
5. **Phase 5**: Memory pressure monitoring

---

## Updated Summary of All Changes

### New Files (4)
- `src-tauri/src/commands/file_watcher.rs`
- `src/hooks/useFileWatcher.ts`
- `LSP-PLAN.md`
- `FUTURE-OPTIM.md`

### Modified Files (8)
- `src-tauri/Cargo.toml`
- `src-tauri/src/commands/mod.rs`
- `src-tauri/src/lib.rs`
- `src/App.tsx`
- `src/components/editor/CodeEditor.tsx`
- `src/hooks/useFileSystem.ts`
- `src/index.css`
- `package.json`

### Documentation Updated (3)
- `AGENTS.md` - Updated implementation status
- `plan.md` - Updated Phase 1 checklist
- `README.md` - Updated Recent Updates and Roadmap

### Dependencies Added
- **Rust**: `notify = "6"` (with `macos_fsevent` feature)
- **npm**: `@codemirror/search`, `@codemirror/lang-html`, `@codemirror/lang-css`, `@codemirror/lang-json`, `@codemirror/lang-markdown`

### Tauri Commands Added
- `start_file_watcher(path: String)` - Start watching a directory
- `stop_file_watcher()` - Stop the current watcher
- `is_watching()` - Check if watcher is active

### Events Added
- `file-change` - Emitted when files change (payload: `{ event_type, paths }`)
